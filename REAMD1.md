# Taro原理

## Taro3之前（重编译时，轻运行时）
***
整体框架：编译时+运行时
编译时会先对代码进⾏编译，转换成各个端上的⼩程序都可以运⾏的代码，然后再在各个⼩程序端上⾯都配上⼀个对应的运⾏时框架进⾏适配，最终让这份代码运⾏在各个⼩程序端上⾯。


编译时是使用 babel-parser 将 Taro 代码解析成抽象语法树，然后通过 babel-types 对抽象语法树进行一系列修改、转换操作，最后再通过 babel-generate 生成对应的目标代码。


## Taro3之后（重运行时）
***
小程序端模拟实现 DOM、BOM API 来让前端框架直接运行在小程序环境中，从而达到小程序和 H5 统一的目的

小程序端端渲染：
先去遍历 Taro DOM Tree 根节点的子元素，再根据每个子元素的类型选择对应的模板来渲染子元素，然后在每个模板中我们又会去遍历当前元素的子元素，以此把整个节点树递归遍历出来

h5端：
通过webComponents实现一套基于小程序规范的组件库和 API 库

## 总结
***
之前采用代码编译成某个端的代码，然后在某个端直接运行。这样的坏处是开发不同端以及不同前端框架的编译脚本，工程量巨大，一旦框架或者端有所更改，这些脚本都需要进行修改。
所以前端框架直接运行在小程序环境中，调⽤Taro提供的 DOM 和 BOM API，把整个渲染到小程序端。



## Taro3组件库
实现组件库：Web Components，它让开发者可以开发出浏览器原生支持的组件。
https://juejin.cn/post/6844903886143094791

